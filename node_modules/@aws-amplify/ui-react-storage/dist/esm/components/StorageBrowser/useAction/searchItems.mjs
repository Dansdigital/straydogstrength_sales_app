/**
 * Normalizes and converts a string to lower case,
 * handling Unicode characters and locale-specific case mappings.
 * Uses NFKD to fully decompose unicode: https://unicode.org/reports/tr15/#Normalization_Forms_Table
 */
function normalize(input) {
    return input
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '') // remove diacritic modifiers
        .toLocaleLowerCase();
}
/**
 * Performs a case-insensitive check to determine if a string includes another string,
 * handling Unicode characters and locale-specific case mappings.
 *
 * @param {string} input - The string to search within.
 * @param {string} query - The substring to search for.
 * @returns {boolean} - Returns `true` if `query` is found in `input` (case-insensitively), otherwise `false`.
 *
 * @example
 * caseInsensitiveIncludes("Photos", "photo"); // true
 * caseInsensitiveIncludes("Hello", "HELLO");   // true
 * caseInsensitiveIncludes("\uFB00", "\u0046\u0046");   // ﬀ = FF true
 * caseInsensitiveIncludes("Cafè", "cafe");   // true
 */
function caseInsensitiveIncludes(input, query) {
    return normalize(input).includes(normalize(query));
}
function searchItems({ prefix = '', items, options, }) {
    const { query, filterBy, groupBy } = options;
    // filter keys that match `filterBy` search option
    const filteredItems = items.filter((item) => {
        const key = typeof filterBy === 'function' ? filterBy(item) : filterBy;
        const path = item[key];
        const suffix = path.slice(prefix.length);
        return caseInsensitiveIncludes(suffix, query);
    });
    if (!groupBy) {
        return filteredItems;
    }
    // group items using the provided grouping delimiter
    const uniquePaths = new Map();
    for (const item of filteredItems) {
        const key = typeof filterBy === 'function' ? filterBy(item) : filterBy;
        const path = item[key];
        const components = path.split(groupBy);
        for (const [i, component] of components.entries()) {
            if (!caseInsensitiveIncludes(component, query)) {
                continue;
            }
            // list of components ending with match
            const matchedPathSegments = components.slice(0, i + 1);
            // create new path
            let matchedPath = matchedPathSegments.join(groupBy);
            const isFolder = matchedPath !== path;
            if (isFolder) {
                matchedPath += groupBy;
            }
            // ignore anything below the prefix for matching
            if (matchedPath.length > prefix.length && !uniquePaths.has(matchedPath)) {
                // add a new item
                uniquePaths.set(matchedPath, {
                    ...item,
                    id: crypto.randomUUID(),
                    [key]: matchedPath,
                    type: isFolder ? 'FOLDER' : 'FILE',
                });
            }
        }
    }
    return Array.from(uniquePaths.values());
}

export { searchItems };
