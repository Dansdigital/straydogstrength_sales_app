import { list } from '@aws-amplify/storage/internals';

const DEFAULT_PAGE_SIZE = 1000;
const parseItems = (items, excludedPath) => items
    // remove root `key` from results
    .filter(({ path }) => path !== excludedPath)
    .map(({ path: key, lastModified, size, eTag }) => {
    const id = crypto.randomUUID();
    // Mark zero byte files as Folders
    if (size === 0 && key.endsWith('/')) {
        return { key, id, type: 'FOLDER' };
    }
    return {
        key,
        id,
        eTag,
        lastModified: lastModified,
        size: size,
        type: 'FILE',
    };
});
const parseExcludedPaths = (paths) => paths?.map((key) => ({ key, id: crypto.randomUUID(), type: 'FOLDER' })) ?? [];
const filterDotItems = (items, prefix) => items.filter((item) => {
    const key = (item.key.startsWith(prefix) ? item.key.substring(prefix.length) : item.key).trim();
    // matches object keys that would cause problems either as folder names in navigation (`/`, `./`, `../`) or as objects (`.`, `..`)
    return !(key === '/' ||
        key === './' ||
        key === '../' ||
        key === '.' ||
        key === '..');
});
const parseResult = ({ excludedSubpaths, items }, prefix) => filterDotItems([...parseExcludedPaths(excludedSubpaths), ...parseItems(items, prefix)], prefix);
const listLocationItemsHandler = async (input) => {
    const { config, prefix, options } = input;
    const { bucket: _bucket, credentials, customEndpoint, region, accountId, } = config;
    const { exclude, delimiter, nextToken, pageSize: _pageSize = DEFAULT_PAGE_SIZE, ..._options } = options ?? {};
    const bucket = { bucketName: _bucket, region };
    const subpathStrategy = {
        delimiter,
        strategy: delimiter ? 'exclude' : 'include',
    };
    // `ListObjectsV2` returns the root `key` on initial request which, when from
    // filtered from `results` by `parseResult`, creates a scenario where the
    // return count of `results` is one item less than the provided `pageSize`.
    // To mitigate, if a `pageSize` is provided and there are no previous `results`
    // or `refresh` is `true` increment the provided `pageSize` by `1`
    const hasOffset = !nextToken;
    const pageSize = hasOffset ? _pageSize + 1 : _pageSize;
    const result = [];
    let nextNextToken = nextToken;
    do {
        const listInput = {
            path: prefix,
            options: {
                nextToken: nextNextToken,
                ..._options,
                bucket,
                customEndpoint,
                expectedBucketOwner: accountId,
                locationCredentialsProvider: credentials,
                pageSize,
                subpathStrategy,
            },
        };
        const output = await list(listInput);
        nextNextToken = output.nextToken;
        const items = parseResult(output, prefix);
        result.push(...(exclude ? items.filter((item) => item.type !== exclude) : items));
    } while (nextNextToken && result.length < pageSize);
    return { items: result, nextToken: nextNextToken };
};

export { filterDotItems, listLocationItemsHandler, parseResult };
