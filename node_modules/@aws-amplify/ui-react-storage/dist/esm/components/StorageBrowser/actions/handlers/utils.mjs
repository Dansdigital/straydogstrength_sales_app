import { MULTIPART_UPLOAD_THRESHOLD_BYTES } from './constants.mjs';

const constructBucket = ({ bucket: bucketName, region, }) => ({ bucketName, region });
const parseAccessGrantLocation = (location) => {
    const { permission, scope, type } = location;
    if (!scope.startsWith('s3://')) {
        throw new Error(`Invalid scope: ${scope}`);
    }
    const id = crypto.randomUUID();
    // remove default path
    const slicedScope = scope.slice(5);
    let bucket, prefix;
    switch (type) {
        case 'BUCKET': {
            // { scope: 's3://bucket/*', type: 'BUCKET', },
            bucket = slicedScope.slice(0, -2);
            prefix = '';
            break;
        }
        case 'PREFIX': {
            // { scope: 's3://bucket/path/*', type: 'PREFIX', },
            bucket = slicedScope.slice(0, slicedScope.indexOf('/'));
            prefix = `${slicedScope.slice(bucket.length + 1, -1)}`;
            break;
        }
        case 'OBJECT': {
            // { scope: 's3://bucket/path/to/object', type: 'OBJECT', },
            bucket = slicedScope.slice(0, slicedScope.indexOf('/'));
            prefix = slicedScope.slice(bucket.length + 1);
            break;
        }
        default: {
            throw new Error(`Invalid location type: ${type}`);
        }
    }
    let permissions;
    switch (permission) {
        case 'READ':
            permissions = ['get', 'list'];
            break;
        case 'READWRITE':
            permissions = ['delete', 'get', 'list', 'write'];
            break;
        case 'WRITE':
            permissions = ['delete', 'write'];
            break;
        default:
            throw new Error(`Invalid location permission: ${permission}`);
    }
    return { bucket, id, permissions: permissions, prefix, type };
};
const isSamePermissions = (permissionsToExclude, locationPermissions) => {
    if (permissionsToExclude.length !== locationPermissions.length) {
        return false;
    }
    const sortedLocationPermissions = locationPermissions.sort();
    return permissionsToExclude
        .sort()
        .every((permission, index) => permission === sortedLocationPermissions[index]);
};
const isSameType = (typeToExclude, locationType) => typeof typeToExclude === 'string'
    ? typeToExclude === locationType
    : typeToExclude.includes(locationType);
const shouldExcludeLocation = ({ permissions, type }, exclude) => {
    const excludedByPermssions = !!(exclude?.exactPermissions &&
        isSamePermissions(exclude.exactPermissions, permissions));
    const excludedByType = !!(exclude?.type && isSameType(exclude.type, type));
    return excludedByPermssions || excludedByType;
};
const getFilteredLocations = (locations, exclude) => locations.reduce((filteredLocations, location) => {
    const parsedLocation = parseAccessGrantLocation(location);
    const isNonFolderLikePrefix = !parsedLocation.prefix.endsWith('/') &&
        parsedLocation.type === 'PREFIX';
    if (isNonFolderLikePrefix) {
        return filteredLocations;
    }
    if (!shouldExcludeLocation(parsedLocation, exclude)) {
        filteredLocations.push(parsedLocation);
    }
    return filteredLocations;
}, []);
const getFileKey = (key) => key.slice(key.lastIndexOf('/') + 1, key.length);
const createFileDataItem = (data) => ({
    ...data,
    fileKey: getFileKey(data.key),
});
const getProgress = ({ totalBytes, transferredBytes, }) => totalBytes ? transferredBytes / totalBytes : undefined;
const isMultipartUpload = (file) => file.size > MULTIPART_UPLOAD_THRESHOLD_BYTES;

export { constructBucket, createFileDataItem, getFileKey, getFilteredLocations, getProgress, isMultipartUpload, parseAccessGrantLocation, shouldExcludeLocation };
