import React__default from 'react';
import { isUndefined, isFunction } from '@aws-amplify/ui';
import { usePaginate } from '../hooks/usePaginate.mjs';
import '@aws-amplify/storage/internals';
import 'aws-amplify/storage';
import { useActionConfigs } from '../../actions/configs/context.mjs';
import '../../actions/configs/defaults.mjs';
import { useFiles } from '../../files/context.mjs';
import { useLocationItems } from '../../locationItems/context.mjs';
import { useStore } from '../../store/context.mjs';
import '../../useAction/context.mjs';
import { useAction } from '../../useAction/useAction.mjs';
import { useList } from '../../useAction/useList.mjs';
import { useSearch } from '../hooks/useSearch.mjs';

const DEFAULT_PAGE_SIZE = 100;
const DEFAULT_LIST_OPTIONS = {
    delimiter: '/',
    pageSize: DEFAULT_PAGE_SIZE,
};
const getDownloadErrorMessageFromFailedDownloadTask = (task) => {
    if (!task)
        return;
    return `Failed to download ${task.data.fileKey ?? task.data.key} due to error: ${task.message}.`;
};
const useLocationDetailView = (options) => {
    const { initialValues, onExit, onNavigate } = options ?? {};
    const listOptionsRef = React__default.useRef({
        ...DEFAULT_LIST_OPTIONS,
        ...initialValues,
    });
    const listOptions = listOptionsRef.current;
    const [{ location, actionType }, storeDispatch] = useStore();
    const [locationItems, locationItemsDispatch] = useLocationItems();
    const filesDispatch = useFiles()[1];
    const { current, key } = location;
    const { permissions, prefix } = current ?? {};
    const { fileDataItems } = locationItems;
    const hasInvalidPrefix = isUndefined(prefix);
    const [{ task }, handleDownload] = useAction('download');
    const [{ value, isLoading, hasError, message }, handleList] = useList('locationItems');
    // set up pagination
    const { items, nextToken, hasExhaustedSearch = false } = value;
    const onPaginate = () => {
        if (hasInvalidPrefix || !nextToken)
            return;
        locationItemsDispatch({ type: 'RESET_LOCATION_ITEMS' });
        handleList({
            prefix: key,
            options: { ...listOptions, nextToken },
        });
    };
    const { currentPage, handlePaginate, handleReset, highestPageVisited, pageItems, } = usePaginate({
        items,
        onPaginate,
        pageSize: listOptions.pageSize,
    });
    const onSearch = (query, includeSubfolders) => {
        if (hasInvalidPrefix)
            return;
        const searchOptions = {
            ...listOptions,
            delimiter: includeSubfolders ? undefined : listOptions.delimiter,
            search: {
                query,
                filterBy: 'key',
                groupBy: includeSubfolders ? listOptions.delimiter : undefined,
            },
        };
        handleReset();
        handleList({ prefix: key, options: searchOptions });
        locationItemsDispatch({ type: 'RESET_LOCATION_ITEMS' });
    };
    const { searchQuery, isSearchingSubfolders: isSearchSubfoldersEnabled, onSearchQueryChange, onSearchSubmit, onToggleSearchSubfolders, resetSearch, } = useSearch({ onSearch });
    const onRefresh = () => {
        if (hasInvalidPrefix)
            return;
        handleReset();
        resetSearch();
        handleList({
            prefix: key,
            options: { ...listOptions, refresh: true },
        });
        locationItemsDispatch({ type: 'RESET_LOCATION_ITEMS' });
    };
    React__default.useEffect(() => {
        if (hasInvalidPrefix)
            return;
        handleList({
            prefix: key,
            options: { ...listOptions, refresh: true },
        });
        handleReset();
    }, [handleList, handleReset, listOptions, hasInvalidPrefix, key]);
    const { actionConfigs } = useActionConfigs();
    const actionItems = React__default.useMemo(() => {
        if (!permissions) {
            return [];
        }
        return !actionConfigs
            ? []
            : Object.entries(actionConfigs).map(([type, { actionListItem }]) => {
                const { icon, hide, disable, label } = actionListItem ?? {};
                return {
                    actionType: type,
                    icon,
                    isDisabled: isFunction(disable)
                        ? disable(fileDataItems)
                        : disable ?? false,
                    isHidden: isFunction(hide) ? hide(permissions) : hide,
                    label,
                };
            });
    }, [actionConfigs, fileDataItems, permissions]);
    return {
        actionItems,
        actionType,
        page: currentPage,
        pageItems,
        location,
        fileDataItems,
        hasError,
        hasDownloadError: task?.status === 'FAILED',
        hasNextPage: !!nextToken,
        highestPageVisited,
        message,
        downloadErrorMessage: getDownloadErrorMessageFromFailedDownloadTask(task),
        isLoading,
        isSearchSubfoldersEnabled,
        onPaginate: handlePaginate,
        searchQuery,
        hasExhaustedSearch,
        onRefresh,
        onActionExit: () => {
            storeDispatch({ type: 'RESET_ACTION_TYPE' });
        },
        onActionSelect: (nextActionType) => {
            options?.onActionSelect?.(nextActionType);
            storeDispatch({
                type: 'CHANGE_ACTION_TYPE',
                actionType: nextActionType,
            });
        },
        onNavigate: (location, path) => {
            onNavigate?.(location, path);
            resetSearch();
            storeDispatch({ type: 'CHANGE_LOCATION', location, path });
            locationItemsDispatch({ type: 'RESET_LOCATION_ITEMS' });
        },
        onDropFiles: (files) => {
            filesDispatch({ type: 'ADD_FILE_ITEMS', files });
            const actionType = 'upload';
            storeDispatch({ type: 'CHANGE_ACTION_TYPE', actionType });
            options?.onActionSelect?.(actionType);
        },
        onDownload: (data) => {
            handleDownload({ data });
        },
        onNavigateHome: () => {
            onExit?.();
            storeDispatch({ type: 'RESET_LOCATION' });
            handleList({
                // @todo: prefix should not be required to refresh
                prefix: prefix ?? '',
                options: { reset: true },
            });
            storeDispatch({ type: 'RESET_ACTION_TYPE' });
            locationItemsDispatch({ type: 'RESET_LOCATION_ITEMS' });
        },
        onSelect: (isSelected, fileItem) => {
            locationItemsDispatch(isSelected
                ? { type: 'REMOVE_LOCATION_ITEM', id: fileItem.id }
                : { type: 'SET_LOCATION_ITEMS', items: [fileItem] });
        },
        onToggleSelectAll: () => {
            const fileItems = pageItems.filter((item) => item.type === 'FILE');
            locationItemsDispatch(fileItems.length === fileDataItems?.length
                ? { type: 'RESET_LOCATION_ITEMS' }
                : { type: 'SET_LOCATION_ITEMS', items: fileItems });
        },
        onSearch: onSearchSubmit,
        onSearchClear: () => {
            resetSearch();
            if (hasInvalidPrefix)
                return;
            handleList({ prefix: key, options: { ...listOptions, refresh: true } });
            handleReset();
        },
        onSearchQueryChange,
        onToggleSearchSubfolders,
    };
};

export { DEFAULT_LIST_OPTIONS, useLocationDetailView };
