import { assertValidationError, StorageValidationErrorCode } from '@aws-amplify/storage/internals';
import { CREDENTIALS_STORE_DEFAULT_SIZE, CREDENTIALS_REFRESH_WINDOW_MS } from './constants.mjs';

const serializedPermissions = (permissions) => permissions.sort().join('_');
const createCacheKey = (location) => `${location.scope}_${serializedPermissions(location.permissions)}`;
const pastTTL = (credentials) => {
    const { expiration } = credentials;
    return expiration.getTime() - CREDENTIALS_REFRESH_WINDOW_MS <= Date.now();
};
const setCacheRecord = (store, key, value) => {
    if (store.capacity === store.values.size) {
        // Pop least used entry. The Map's key are in insertion order.
        // So first key is the last recently inserted.
        const [oldestKey] = store.values.keys();
        store.values.delete(oldestKey);
        // TODO(@AllanZhengYP): Add log info when record is evicted.
    }
    // Add latest used value to the cache.
    store.values.set(key, value);
};
const dispatchRefresh = (refreshHandler, value, onRefreshFailure) => {
    if (value.inflightCredentials) {
        return value.inflightCredentials;
    }
    value.inflightCredentials = (async () => {
        try {
            const { credentials } = await refreshHandler({
                scope: value.scope,
                permissions: value.permissions,
            });
            value.credentials = credentials;
            return { credentials };
        }
        catch (e) {
            onRefreshFailure();
            throw e;
        }
        finally {
            value.inflightCredentials = undefined;
        }
    })();
    return value.inflightCredentials;
};
/**
 * @internal
 */
const initStore = (refreshHandler, size = CREDENTIALS_STORE_DEFAULT_SIZE) => {
    assertValidationError(size > 0, StorageValidationErrorCode.InvalidLocationCredentialsCacheSize);
    return {
        capacity: size,
        refreshHandler,
        values: new Map(),
    };
};
const getCacheValue = (store, location) => {
    const cacheKey = createCacheKey(location);
    const cachedValue = store.values.get(cacheKey);
    const cachedCredentials = cachedValue?.credentials;
    if (!cachedCredentials) {
        return null;
    }
    // Delete and re-insert to key to map to indicate a latest reference in LRU.
    store.values.delete(cacheKey);
    if (!pastTTL(cachedCredentials)) {
        // TODO(@AllanZhengYP): If the credential is still valid but will expire
        // soon, we should return credentials AND dispatch a refresh.
        store.values.set(cacheKey, cachedValue);
        return cachedCredentials;
    }
    return null;
};
/**
 * Fetch new credentials value with refresh handler and cache the result in
 * LRU cache.
 * @internal
 */
const fetchNewValue = async (store, location) => {
    const storeValues = store.values;
    const key = createCacheKey(location);
    if (!storeValues.has(key)) {
        setCacheRecord(store, key, location);
    }
    const storeValue = storeValues.get(key);
    return dispatchRefresh(store.refreshHandler, storeValue, () => {
        store.values.delete(key);
    });
};

export { fetchNewValue, getCacheValue, initStore };
